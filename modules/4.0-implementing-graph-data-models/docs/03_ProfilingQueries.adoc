= Profiling Queries
:slug: 03-profiling-queries
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Implementing a Refactor

== About this module

At the end of this module, you should be able to:
[square]
* Profile queries against the graph.
* Determine if a query can be improved.

== Workflow for profiling queries

[.notes]
--
Understanding the performance of the queries for your use cases is an important part of implementing a graph data model.
Here is the workflow you should use:
--

. Load data into the graph.
. Create queries that answer the application questions.
. Execute the queries against the data to see if they retrieve the correct information.
. PROFILE the query execution.
. Identify problems and weaknesses in the query execution.
.. Can the query be rewritten to perform better?
.. Do we need to refactor the graph?
. If necessary, modify the graph data model and refactor the graph.
. PROFILE  the same type of query against the refactored graph.

[NOTE]
The new query will be different due to the change in the graph data model.

== Example: Profiling a query

Here is the code to profile a query that retrieves all connections that have a destination of _LAS_:

[source,cypher]
----
PROFILE
MATCH (origin:Airport)-[c:CONNECTED_TO]->(destination:Airport)
WHERE destination.code = 'LAS'
RETURN origin, destination, c LIMIT 10
----

[.notes]
--
To profile a query, simply add `PROFILE` to the beginning of the Cypher statement.

This executes the query as normal, but gives a different output, which shows every step in the query execution plan, and how much each step cost.

With `PROFILE`, the main metric we consider is *db hits*.
Execution time is important, but that is generally a result of administrative factors, like bandwidth, memory, and traffic volume.
*db hits*, on the other hand, are entirely a function of the data model and query.
--

image::PROFILEExample.png[PROFILEExample,width=1000,align=center]

=== Analyzing the query profile - 1

image::PROFILEExample1.png[PROFILEExample1,width=1000,align=center]

[.notes]
--
The first step in any query is locating the anchor.
In this case, Neo4j will anchor on the destination node set, because that one has a property filter while origin does not.

According to the PROFILE, the anchor was located by first locating all Airport nodes under the Airport label, then scanning to find the desired code property value.
This required 7 and 12 db hits respectively, and got us down to a single node--the perfect anchor set.

This label scan + property scan is MUCH less efficient than an index lookup.  We will observe that in a later exercise.
--

=== Analyzing the query profile - 2

image::PROFILEExample2.png[PROFILEExample2,width=1000,align=center]

[.notes]
--
With the anchor set identified, Neo4j then expanded along every incoming CONNECTED_TO relationship, finding 11 such paths with 13 and 11 db hits respectively.

Next, Neo4j checked which of those paths terminated at an origin node labeled Airport.
Based on what we know about our model, it is no surprise that all 11 paths qualified.
This is an example of providing an unnecessary filter.
We could have dispensed with the Airport label on the origin set, and saved 11 db hits.
--

=== Analyzing the query profile - 3

image::PROFILEExample3.png[PROFILEExample3,width=1000,align=center]

[.notes]
--
With traversal finished, Neo4j then returned the results, filtered by the `LIMIT` clause.
This operates entirely upon the objects already in memory, and so requires no db hits.

When all is said and done, you can see that total cost of this was 43 db hits.
We could have saved 11 by not filtering on Airport for the origin nodes.
In addition, recall that identifying the anchor required 7+12 = 19 DB hits.
So our best opportunity for improving the performance of this query lies in finding a way to anchor more efficiently.
PROFILE made that obvious, and we would have been unable to discover that by any other means.
--

[.student-exercise]
== Exercise 3: Profiling queries

[.small]
--
In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-neo4j-modeling-exercises]

and follow the instructions for Exercise 3.

[NOTE]
This exercise has 2 steps.
Estimated time to complete: 15 minutes.
--

== Do we need to change the model?

In the previous exercise, we asked this question:

What are the airports and flight information for flight number 1016 for airline WN?

This is our current model:

image::OriginalAirportModel.png[OriginalAirportModel,width=1000,align=center]

Here is the query:

[source,cypher]
----
PROFILE
MATCH  (origin:Airport)-[connection:CONNECTED_TO]->(destination:Airport)
WHERE connection.airline = 'WN' AND connection.flightNumber = '1016'
RETURN origin.code, destination.code, connection.date, connection.departure, connection.arrival
----

Here is the profile for this query:

image::ProfileQuestion2.png[ProfileQuestion2,width=200,align=center]

[.notes]
--
This query required 4382 db hits.

Recall that our dataset only has 100 flights in it.
In other words, in order to answer this question, we needed to hit the entire graph twice.
The query executed reasonably quickly in terms of milliseconds,  that is largely because the dataset is not large.
Hence our insistence on using db hits as a measure--from that, we can tell that this query is grossly inefficient on this data model!

In the next lesson, we will implement a refactor to fix this.

--
[.quiz]
== Check your understanding

// Elaine resume here
=== Question 1

[.statement]
What Cypher statement do you use to import data from a CSV file?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] `LOAD DATA`
- [ ] `IMPORT DATA`
- [x] `LOAD CSV`
- [ ] `IMPORT CSV`

=== Question 2

[.statement]

[.statement]
Up to how many lines can you import data using `LOAD CSV`

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] 1K
- [ ] 10K
- [x] 100K
- [ ] 1M

=== Question 3

[.statement]
When you import data using `LOAD CSV`, where can the CSV data come from?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] File that has been placed in the *import* folder relative to the database instance.
- [ ] File that has been placed in the Neo4j Desktop project.
- [x] File at a network location accessible via http/https.
- [ ] A JDBC connection that is open.

[.summary]
== Summary

You should now be able to:
[square]
* Write Cypher code to import CSV data with Cypher.
* Confirm that the data has been loaded.
