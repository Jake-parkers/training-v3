
= Checking Database Consistency
:doctype: book
:toc: left
:toclevels: 3
:prevsecttitle: Changing the Database Location
:prevsect: 6
:currsect: 7
:nextsecttitle: Scripting to Manage a Neo4j Instance
:nextsect: 8
:experimental:
:imagesdir: ../images
:manual: http://neo4j.com/docs/operations-manual/4.0

////
ifdef::backend-html5[]

include::scripts.txt[]

endif::backend-html5[]
////

== About this module

Next, you will learn how to check the consistency of a Neo4j database.

At the end of this module, you should be able to:
[square]
* Use neo4j-admin to check the consistency of a Neo4j database.

== Neo4j instance files

Depending on your platform, a Neo4j instance's files are, by default, placed as described https://neo4j.com/docs/operations-manual/4.0/configuration/file-locations/[here].
Here is a brief overview of the default directories you will frequently use for managing the Neo4j instance in Debian.

[cols="20,80", options="header",stripes="none"]
|====

|*Purpose of directory*
|*Description*
|
{set:cellbgcolor:white}
Tools
|The  */usr/bin* directory contains the tooling scripts you will typically run to manage the Neo4j instance.
|Configuration
|*neo4j.conf* is the primary configuration file for the Neo4j instance and resides in the */etc/neo4j* directory.
|Logging
|The */var/log/neo4j* directory contains log files that you can monitor.
|Database(s)
|The */var/lib/neo4j/data* directory contains the database(s).
|====
{set:cellbgcolor!}

== Post-installation preparation

In this training, all screenshots and examples are shown using Neo4j Enterprise Edition installed as a Debian package.
In your real application environment, if your system is different, you will need to adjust file locations and how you manage the Neo4j instance.

When you are setting up a production environment, you want to control who can manage the Neo4j instance.
You will also want to control when the Neo4j instance starts as you will performing some configuration changes and database operations that may require that the instance to be stopped.

When Neo4j is installed as a Debian package, the _neo4j_ service is disabled. On most platforms, the Neo4j instance is not automatically started.

=== Post-install: Changing the _neo4j_ password for the Neo4j instance

After you install Neo4j and before you start the Neo4j instance, a best practice is to change the default password for the user _neo4j_.
You do this on all platforms, except when you have installed a Debian package.
You will learn about changing the _neo4j_ password on Debian later in this module as we use Debian for this course.

On systems, other than Debian, you change the password for the _neo4j_ user by executing the following command:

`[sudo] bin/neo4j-admin set-initial-password newPassword`

where _newPassword_ is a password you will remember.

[NOTE]
If at some point you have forgotten the admin password for your installation or you need to change it, you can reset the password by following the steps
https://neo4j.com/docs/operations-manual/4.0/configuration/password-and-user-recovery/[here]

=== Post-install: Debian

Initially and *only on Debian*, you should disable _neo4j_ as a service that is started automatically when the system starts.
You do this with this command:

`[sudo] systemctl disable neo4j`

In addition, you should create the directory */var/run/neo4j* that is owned by _neo4j:neo4j_.
This is where the PID for the currently running Neo4j instance is placed.

You will perform these steps later in the Exercise 2.

== Managing the Neo4j instance

When the instance is started, it creates a database directory named *neo4j* in the default location which is a directory under */var/lib/neo4j/data/databases*. You can start and stop the instance regardless of whether the _neo4j_ service is enabled.

You start, stop, restart, and check the status of the Neo4j instance on Debian as follows:

[square]
* `[sudo] systemctl start neo4j`
* `[sudo] systemctl stop neo4j`
* `[sudo] systemctl restart neo4j`
* `systemctl status neo4j`

You start, stop, restart and check the status of the Neo4j instance on non-Debian systems as follows:

[square]
* `[sudo] bin/neo4j start`
* `[sudo] bin/neo4j stop`
* `[sudo] bin/neo4j restart`
* `bin/neo4j status`

When the Neo4j instance starts, it opens the database, and writes to the directories for the database and to the log file.

=== Checking the status of the instance

At any time, you can check the status of the Neo4j instance.

You check the status of the instance as follows:

`systemctl status neo4j`

Here is an example where we check the status of the Neo4j instance:

image::Neo4j_started.png[Neo4j_started,width=800,align=center]

Here we see that the instance is started. Notice that the service is disabled as well.
After the instance is started you can identify the process ID (Main PID) from the status command on Debian.
It is sometimes helpful to know the process ID of the Neo4j instance (JVM) in the event that it is unresponsive and you must kill it.

However, knowing whether the instance is started (active) is generally not sufficient, especially if you have made some configuration changes.
You can view details of the Neo4j instance by examining the log file.

=== Viewing the neo4j log

The status command gives you a short glimpse of the status of the Neo4j instance. In some cases, although the instance is _active_, it may not have started successfully. You may want to examine more information about the instance, such as the directories it is using at runtime and information about activity against the instance, and especially if any errors occurred during startup. As an administrator, you should become familiar with the types of records that are written to the log files for the Neo4j instance.

You can view the log file for the instance on Debian as follows:

[square]
* `journalctl -u neo4j`  to view the entire neo4j log file.
* `journalctl -e -u neo4j` to view the end of the neo4j log file.
* `journalctl -u neo4j -b > neo4j.log` where you can view *neo4j.log* in an editor.

Here is the result from `journalctl` where we want to view then end of the log file:

image::JournalEnd.png[JournalEnd,width=800,align=center]

When the Neo4j instance starts, you can also confirm that it is started by seeing the _Started_ record in the log file.

[NOTE]
You can also view the log file in the *logs* directory on all platforms.

[.slide-title.has-gold-background.has-team-background]
== *Exercise #2: Managing the Neo4j instance*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]


== Using `cypher-shell`

`cypher-shell` enables you to access the Neo4j database from a terminal window.  You simply log into the database using `cypher-shell` with your credentials:

`/usr/bin/cypher-shell -u <username> -p <password>`

Once authenticated, you enter Cypher statements to execute just as you would in a Neo4j Browser session.
One caveat with `cypher-shell`, however is that all Cypher commands [.underline]#must# end with `;`.
You exit `cypher-shell` with the command `:exit`.

=== Example: Using `cypher-shell`

Here is an example showing that we can successfully log in to the database for the Neo4j instance, providing the default credentials _neo4j/neo4j_:
Since this is the first login to the database, you must change the password from _neo4j_ to a password you will remember.

image::InitialLogin-cypher-shell.png[InitialLogin-cypher-shell,width=800,align=center]

In this example we changed the password to _training-helps_.

When you are done with `cypher-shell`, you enter `:exit` to exit.

[NOTE]
If you set the environment variables NEO4J_USER and NEO4J_PASSWORD with their respective values, then you need not enter your credentials when logging into `cypher-shell`.


=== Example: Using `cypher-shell` providing credentials as arguments

You can also specify the username and password at the command level to use `cypher-shell` as arguments .

image::Cypher-shell-withParms.png[Cypher-shell-withParms,width=800,align=center]

== Accessing the system database

After you have successfully logged in to the Neo4j instance using `cypher-shell`, you can execute system commands against the Neo4j instance.
By default, you are connected to the default Neo4j database, _neo4j_, which is a user database.

System commands use the _system_ database and are primarily used to:

* View the status of the databases being served by the Neo4j instance
* Create or drop a user database.
* Start or stop a user database.

To access the system database, you enter `:USE system`.

image::UseSystem.png[UseSystem,width=1000,align=center]

Notice that the prompt neo4j@system tells us that all commands we enter will be against the system database.

=== Viewing databases for the Neo4j instance

Using the _system_ database, you can view all of the databases served by this Neo4j instance by entering the command `SHOW DATABASES;`:

[NOTE] For all commands and cypher statements, you must end them with the `;` character.

image::ShowInitialDatabases.png[ShowInitialDatabases,width=1000,align=center]

Here we see that this Neo4j instance that we have connected to has the system database and the neo4j database, which is the default name of the user database.
A Neo4j instance has one system database and any number of user databases.
After you have created more than one user database, you can configure any single user database as the default database.

=== Selecting the user database to access

In a client session, you can only access a single user database at a time, even though multiple databases may be online (started).
You use the :USE command to select the user database to connect to.

Here we switch back to the default, _neo4j_ user database by specifying `:USE neo4j`.
Then you can create or access the data in this user database.
For example, we access the user database by creating a node with the label, _Person_ and a _name_ of "John Doe", retrieving it, and then deleting it.

image::AccessUserDatabase.png[AccessUserDatabase,width=1000,align=center]

=== Sending Cypher statements to the `cypher-shell` session

When you log in to `cypher-shell`, you are connected to the default database, which is by default, _neo4j_.

You can use `cypher-shell` to populate the default database by sending pre-written Cypher statements to the database to execute.

image::ImportCypher.png[ImportCypher,width=1000,align=center]

Here we have download a file named *movieDB.cypher* that contains the Cypher statements to create the Movie graph.
We simply use these Cypher statements as input when we start the `cypher-shell` session.
They are automatically executed against the default database, _neo4j_.

[.slide-title.has-gold-background.has-team-background]
== *Exercise #3: Using `cypher-shell`*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]

== Creating databases

In Neo4j 4.0 Enterprise Edition, a Neo4j instance can host multiple user databases. To create a database, you connect to a started Neo4j instance with `cypher-shell`.

Here are the commands to create a database:

----
:USE system
CREATE DATABASE <database-name>
----

The database must not already exist (Check with the `SHOW DATABASES` command). This command creates the database and starts it.

Here are some database naming rules:

* Length must be between 3 and 63 characters.
* The first character of a name must be an ASCII alphabetic character.
* Subsequent characters must be ASCII alphabetic or numeric characters, dots or dashes; [a..z][0..9].-
* Names are case-insensitive and normalized to lowercase.
* Names that begin with an underscore and with the prefix system are reserved for internal use.
* All of the above commands are executed as Cypher commands, and the database name is subject to the standard Cypher restrictions on valid identifiers. In particular, the - (dash) character is not legal in Cypher variables, and therefore names with dashes need to be escaped by enclosing with back-ticks. For example, CREATE DATABASE `main-db`.

Once a database is created, you cannot rename it.

=== Creating a database

Here we create a database named _myfirstdatabase_:

image::CreateDatabase.png[CreateDatabase,width=1000,align=center]

You can view the directory created for the database:

image::DatabaseFiles.png[DatabaseFiles,width=1000,align=center]

== Starting and stopping a database

When a database is started, it uses VM resources. If the application is not actively using a database, you can stop it or restart it as needed.

image::StopStartDatabase.png[StopStartDatabase,width=1000,align=center]

== Initial database configuration settings

The *neo4j.conf* file contains settings related to the name of the default database.

`dbms.default_database` specifies the default database clients will connect to when they do not specify a specific database.

`dbms.max_databases` specifies the maximum number of databases the Neo4j instance will allow.

image::ChangeDefaultDatabase.png[ChangeDefaultDatabase,width=1000,align=center]

[NOTE]
Whenever you make a change to the *neo4j.conf* file, you must restart the Neo4j instance. (`[sudo] systemctl restart neo4j`)
A best practice is to examine the log file for the Neo4j instance after you have made any configuration changes to ensure that the instance starts with no errors.

== Deleting a database

You delete a database as shown here where we drop the database _neo4j_.
We can drop it because it is no longer the default database.
You need not stop the database before your drop it, but dropping it is a permanent deletion of the database.

image::DropDatabase.png[DropDatabase,width=1000,align=center]

== Resetting a database

Suppose you have a database that has been populated with data, constraints, and/or indexes.
You want to reuse the database and reset it to be empty with no data, constraints, or indexes.
One way that you can achieve this is to drop the database and then create it again.
Another way that you can do is is to use the following command:

----
CREATE OR REPLACE <database>;
----

== Conditionally creating a database

If you are scripting the creation of databases, you can also create a database if it does not exist as follows:

----
CREATE <database> IF NOT EXISTS;
----

[NOTE]
You cannot use `CREATE OR REPLACE` together with `IF NOT EXISTS`.

[.slide-title.has-gold-background.has-team-background]
== *Exercise #4: Creating and deleting a database*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]


== Copying a Neo4j database

You or one of your application developers may want to copy a Neo4j database.
Perhaps the developers are at a juncture in their development where they want to save what they have worked on thus far.
Or perhaps they want to give a copy of the database to another developer to work with on a different system.

The structure of a Neo4j database is proprietary and could change from one release to another.
You should [underline]#never# copy the database files from one location in the filesystem/network to another location.

There are two ways that you can copy a database:

. Create a copy within the same Neo4j instance.
. Create a copy (dump file) that you will give to another developer to load into their Neo4j instance running on a different system.

=== Copying a database within the same Neo4j instance

To copy a database within the same Neo4j instance, the source database must be stopped.
Additionally, the target database that you will be creating must not exist.

You use the `neo4j-admin` tool to copy a database within your Neo4j instance. Here are the steps:

. Ensure the Neo4j instance is started.
. In `cypher-shell` stop the source database you want to copy.
. Exit `cypher-shell`.
. In a different terminal window, enter this as the user, neo4j:
----
/usr/bin/neo4j-admin copy --from-database=<sourceDB> --to-database=<targetDB>
----
[start=5]
. In `cypher-shell' create <targetDB>.

There are other options you can use to customize what is copied. See the _Neo4j Operations Manual_ for details.

=== Creating a dump file from a database

To create a dump file of a database, you must:

. Ensure the Neo4j instance is started.
. Stop the database you want to dump.
. Ensure that the directory where you will dump the database exists.
[start=4]
. As the neo4j users, you can use the `dump` command of the `neo4j-admin` tool to create the dump file as follows:
----
/usr/bin/neo4j-admin dump --database=<sourceDB> --to=<absolute path to dump file>
----

Note that the user, neo4j, must have write access to the directory.

This will create a  dump file that can now be transferred between systems to create a new database on a different system.

=== Creating a database from a dump file

Then, if you want to create a database from any offline backup file to use for a Neo4j instance, you must:

. Use the `load` command of the `neo4j-admin` tool as the neo4j users, to create the database from the dump file as follows:
----
/usr/bin/neo4j-admin load --database=<targetDB> --from=<absolute path to dump file>
----
[start=2]
. In `cypher-shell' create <targetDB>.

[.slide-title.has-gold-background.has-team-background]
== *Exercise #5: Copying databases*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]


== Modifying the location of the database

If you do not want the databases used by the Neo4j instance to reside in the same location as the Neo4j installation, you can modify its location in the *neo4j.conf* file. If you specify a new location for the data, it must exist in the filesystem and the directory must be owned by _neo4j:neo4j_.

Here we have specified a new location for the data in the configuration file:

image::ChangeDatabaseDirectory.png[ChangeDatabaseDirectory,width=800,align=center]

In addition, we have specified mainDB as the default database.

=== Best practice for configuration modifications

Here is a best practice you should follow when managing a Neo4j installation.
It is easier to place all changed property values at the end of the *neo4j.conf* file.
That way, you can easily see what non-default values you have configured.

Here is an example:

image::BestPracticeConfigChangesAtEnd.png[BestPracticeConfigChangesAtEnd,width=800,align=center]

=== Starting Neo4j instance with a new location

After you have modified the *neo4j.conf* file with the new location for the databases, you must:

. Ensure the directory exists.
. Change the owner of the directory to be neo4j.
. Start or restart the Neo4j instance.
. Confirm that the instance started with no errors.

image::Neo4jStarted-newLocation1.png[Neo4jStarted-newLocation1,width=800,align=center]

When you start the Neo4j instance using a different location for the databases, it first creates and starts a database named whatever you have specified as the default database.
If you did not specify the default database in the configuration file, it will create a database named _neo4j_.

Here are the new databases in the new location:

image::Neo4jStarted-newLocation2.png[Neo4jStarted-newLocation2,width=800,align=center]

If you have existing databases that you want to reside in a different location for the Neo4j instance, remember that you must dump and load the databases to safely copy them to the new location.

==== Password change required

Just as you needed to change the password for the admin user, neo4j the first time you accessed a database, you must do the same here for this new location of the Neo4j databases:

image::passwordChangeNewLocation.png[passwordChangeNewLocation,width=800,align=center]

[.slide-title.has-gold-background.has-team-background]
== *Exercise #6: Modifying the location of the databases*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]


== Checking the consistency of a database

A database's consistency could be compromised if a software or hardware failure has occurred that affects the Neo4j database.
You will learn later in this module about live backups, but if you have reason to believe that a specific database has been corrupted,  you can perform a consistency check on it.

The Neo4j database must be stopped to perform the consistency check.

Here is how you use the `neo4j-admin` tool to check the consistency of the database:

`neo4j-admin check-consistency --database=<database-name> --report-dir=report-location [--verbose]`

The database named _database-name_ is found in the Neo4j instance.
If the tool comes back with no error, then the database is consistent.
Otherwise, an error is returned and a report is written to _report-location_.
You can specify verbose reporting. See the https://neo4j.com/docs/operations-manual/4.0/tools/consistency-checker/[Neo4j Operations Manual] for more options. For example, you can check the consistency of a backup which is a best practice.

Suppose we had loaded the *movies2* database with `neo4j-admin`. Here is what a successful run of the consistency checker should produce:

image::ConsistentPassed.png[ConsistentPassed,width=1000,align=center]

No report is written to the reports directory because the consistency check passed.

=== Inconsistencies found

Here is an example of what an unsuccessful run of the consistency checker should produce:

image::Inconsistencies.png[Inconsistencies,width=1000,align=center]

If inconsistencies are found, a report is generated and placed in the directory specified for the report location.

Inconsistencies in a database are a serious matter that should be looked into with the help of Neo4j Technical Support. 

[.slide-title.has-gold-background.has-team-background]
== *Exercise #7: Checking consistency of a database*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]

== Scripting with cypher-shell

As a database administrator, you may need to automate changes to databases.
The most common types of changes that administrators may want to perform are related to the application.
As an administrator, you work with architects and developers to created scripts to:

* Create or drop databases
* Create constraints
* Create indexes
* Load data
* Update data
* Restructure the graph (change graph data model)
* Add users and access control.

=== Examples: Adding constraints

Suppose that we create 3 files to make changes:

*1. AddConstraintsMovies.cypher* that contains the Cypher statements to execute in `cypher-shell`:
----
CREATE CONSTRAINT ON (m:Movie) ASSERT m.title IS UNIQUE;
CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE;
CALL db.constraints();
----
Note that each Cypher statement must end with a `;`.

*2. AddConstraints.sh* that invokes `cypher-shell` using a set of Cypher statements and specifies verbose output:
----
cat /usr/local/work/AddConstraintsMovies.cypher | /usr/bin/cypher-shell -u neo4j -p <InstancePassword>  --database movies --format verbose
----

*3. PrepareDB.sh* that initializes the log file, *PrepareDB.log*, and calls the script to add the constraints:
----
rm -rf /usr/local/work/PrepareDB.log
/usr/local/work/AddConstraints.sh 2>&1 >> /usr/local/work/
PrepareDB.log
# Other scripts here
----

When the *PrepareDB.sh* script runs its scripts, all output will be written to the log file, including error output. Then you can simply check the log file to make sure it ran as expected.
Using the Cypher file, together with the run scripts, you can perform something like this to automate changes to a database or set of databases.

[.slide-title.has-gold-background.has-team-background]
==  *Exercise #8: Scripting changes to the database*

//ifndef::backend-htlm5[]
Refer to the *Exercise Guide* for instructions.
//endif::[]

//ifdef::backend-htlm5[]
//include::exercises/03_ManagingNeo4jDatabases.adoc
//endif::[]


== Managing plugins

Some applications can use Neo4j out-of-the-box, but many applications require additional functionality that could be:

[square]
* A library supported by Neo4j such as GraphQL or GRAPH ALGORITHMS.
* A community-supported library, such as APOC.
* Custom functionality that has been written by the developers of your application.

We refer to this additional functionality as a _plugin_ that contains specific procedures. A _plugin_ is typically specific to a particular release of Neo4j. In many cases, if you upgrade to a later version of Neo4j, you may also need to install a new _plugin_. First, you should understand how to view the procedures available for use with the Neo4j instance. You do so by executing the Cypher statement `CALL db.procedures();`.

=== Retrieving available procedures

Here is an example of a script you can run to produce a file, *Procedures.txt* that contain the names of the procedures currently available for the Neo4j instance:

----
echo "CALL dbms.procedures() YIELD name;" | /usr/bin/cypher-shell -u neo4j -p training-helps --format plain > /usr/local/work/Procedures.txt
----

This script calls `dbms.procedures()` to return the name of each procedure in the list returned.

Here is a view of *Procedures.txt*:

image::DefaultProcedures.png[DefaultProcedures,width=800,align=center]

By default, the procedures available to the Neo4j instance are the built-in procedures that are named db.* and dbms.*.

=== Adding a plugin to the Neo4j instance

To add a plugin to your Neo4j instance, you must first obtain the *.jar* file. It is important to confirm that the *.jar* file you will use is compatible with the version of Neo4j that you are using. For example, a plugin released for release 3.4 of Neo4j can be used by a Neo4j 3.5 instance, but the converse may not be true. You must check with the developers of the plugin for compatibility.

Some plugins require a configuration change. You should understand the configuration changes required for any plugin you are installing.

[NOTE]
When you install Neo4j, the *plugins* directory contains a *README.txt* file that contains instructions related to sandboxing and whitelisting. These instructions will change in future releases of Neo4j.

==== Sandboxing and whitelisting

Neo4j provides _sandboxing_ to ensure that procedures do not inadvertently use insecure APIs. For example, when writing custom code it is possible to access Neo4j APIs that are not publicly supported, and these internal APIs are subject to change, without notice.
Additionally, their use comes with the risk of performing insecure actions. The sandboxing
functionality limits the use of extensions to publicly supported APIs, which exclusively contain safe operations,
or contain security checks.

Neo4j _whitelisting_ can be used to allow loading only a few extensions from a larger library.
The configuration setting _dbms.security.procedures.whitelist_ is used to name certain procedures that should be
available from a library. It defines a comma-separated list of procedures that are to be loaded.
The list may contain both fully-qualified procedure names, and partial names with the wildcard *.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

=== Example: Installing the Graph Algorithms plugin

Suppose we wanted to install the Graph Algorithms library that is compatible with Neo4j 3.5. We find the library in GitHub and simply download the *.jar* file. Here is the https://github.com/neo4j-contrib/neo4j-graph-algorithms/releases[release area] in GitHub for the graph algorithms library:

image::GitHubGraphAlgos.png[GitHubGraphAlgos,width=800,align=center]

The main page for https://github.com/neo4j-contrib/neo4j-graph-algorithms[Graph Algorithms] in GitHub contains details about the plugin and instructions for installing it.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Download and ownership of plugin

You download any plugins that your application will use to the /var/lib/neo4j/plugins directory:

image::GraphAlgos.png[GraphAlgos,width=1000,align=center]

Ensure that the *.jar* file is owned by _neo4j:neo4j_ and that it has execute permissions.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Sandboxing

The graph algorithms plugin requires _sandboxing_.
Here is how we enable the procedures in the graph algorithms plugin. We modify the _Miscellaneous Configuration_ section of the *neo4j.conf* file as follows:

image::ConfigGraphAlgos.png[ConfigGraphAlgos,width=600,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Restart with plugin

You must then start or restart the Neo4j instance. Once started, you can then run the script to return the names of the procedures that are available to the Neo4j instance. Here we see that we have the additional procedures for the graph algorithms plugin:

image::GraphAlgosInstalled.png[GraphAlgosInstalled,width=700,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

=== Example: Installing the APOC plugin

https://github.com/neo4j-contrib/neo4j-apoc-procedures[APOC] (Awesome Procedures on Cypher) is a very popular plugin used by many applications. It contains over 450 user-defined procedures that make accessing a graph incredibly efficient and much easier than writing your own Cypher statements to do the same thing.

You obtain the plugin from the APOC https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases[releases] page:

image::APOCDownloadPage.png[APOCDownloadPage,width=800,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Download and ownership of plugin

Here we download the *.jar* file, change its permissions to execute, and change the owner to be _neo4j:neo4j_.

image::APOC.png[APOC,width=800,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Sandboxing

After you have placed the *.jar* file into the *plugins* directory, you must modify the configuration for the instance as described in the main page for APOC. As described on this page, you have an option of either _sandboxing_ or _whitelisting_ the procedures of the plugin. How much of the APOC library is used by your application is determined by the developers so you should use them as a resource for this type of configuration change.

Suppose we want to allow [.underline]#all# APOC procedures to be available to this Neo4j instance. We would sandbox the plugin in the *neo4j.conf* file as follows, similar to how we sandboxed the graph algorithms where we specify `dbms.security.procedures.unrestricted=algo.*,apoc.*`.

image::APOCConfig.png[APOCConfig,width=600,align=center]

Since APOC is large, you will most likely want to whitebox specific procedures so that only the procedures needed by the application are loaded into the Neo4j instance at runtime.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

==== Example: Restart with plugin

And here we see the results after restarting the Neo4j instance and running the script to list the procedures loaded in the instance:

image::APOCLoaded.png[APOCLoaded,width=600,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

===  *Exercise #7: Install a plugin*

In this Exercise, you will install the Spatial library for use by your Neo4j instance and you will create and execute a script to report all of the procedures available to the Neo4j instance.

*Before you begin*:

. Stop the Neo4j instance.
. Make sure you have a terminal window open for executing test commands.

*Exercise steps*:

. In a Web browser, go to the GitHub repository for the https://github.com/neo4j-contrib/spatial[Neo4j Spacial Library].
. On the main page for this repository, find the latest release of the library that is compatible with your version of Neo4j Enterprise Edition.
. Download the already-built *.jar* file into the */var/lib/neo4j/plugins* directory.
. Ensure that the file size is correct and that the file name ends with *.jar*.
. Change the owner of the *.jar* file to _neo4j:neo4j_ and add execute permissions to the file.
. Restart the Neo4j instance.
. Follow the steps on the GitHub page for testing the library.

For example, you should see the following in the repository main page:

image::L03-Ex7-GetSpatialLibrary.png[Ex7-GetSpatialLibrary,width=800,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

Here is how you download the *.jar* file into the */var/lib/neo4j/plugins* directory. You should confirm that the file size is correct and that the owner is _neo4j:neo4j_ with execute permissions.

image::L03-Ex7-SpatialLibrary.png[Ex7-SpatialLibrary,width=800,align=center]


Here is what you should see when you execute the first `curl` command:

image::L03-Ex7-SpatialQuery1.png[Ex7-SpatialQuery1,width=1000,align=center]

Here is what you should see when you execute the second `curl` command:

image::L03-Ex7-SpatialQuery2.png[Ex7-SpatialQuery2,width=1000,align=center]

[start=8]
. In the */usr/local/work* directory, create a script named *ListProcedures.sh* that will write the list of procedures available to the Neo4j instance to the */usr/local/work/Procedures.txt* file.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

[start=9]
. Run the *ListProcedures.sh* script and examine the contents to also verify that the plugin has been installed. The *Procedures.txt* file should contain these items:

image::L03-Ex7-SpatialLibraryLoaded.png[Ex7-SpatialLibraryLoaded,width=600,align=center]


== Configuring connector ports for the Neo4j instance

The Neo4j instance uses https://neo4j.com/docs/operations-manual/3.5/configuration/ports/[default port numbers] that may conflict with other processes on your system. The ports frequently used are the connector ports:

[cols="10,10,80", options="header",stripes="none"]
|====
 *Name*
| *Port Number*
| *Description*
|
{set:cellbgcolor:white}
 HTTP
| 7474
| Used by Neo4j Browser and REST API. It is *not* encrypted so it should never be exposed externally.
| HTTPS
| 7473
| Used by REST API. Requires additional SSL configuration.
| Bolt
| 7687
| Bolt connection used by Neo4j Browser, cypher-shell, and client applications.
|====
{set:cellbgcolor!}

=== Modifying the default connector ports

If any of these ports conflict with ports already used on your system, you can change these connector ports by modifying these property values in the *neo4j.conf* file:

----
# Bolt connector
dbms.connector.bolt.enabled=true
#dbms.connector.bolt.tls_level=OPTIONAL
#dbms.connector.bolt.listen_address=:*7687*

# HTTP Connector. There can be zero or one HTTP connectors.
dbms.connector.http.enabled=true
#dbms.connector.http.listen_address=:*7474*

# HTTPS Connector. There can be zero or one HTTPS connectors.
dbms.connector.https.enabled=true
#dbms.connector.https.listen_address=:*7473*
----

As you learn more about some of the other administrative tasks for a Neo4j instance, you will work with other ports.

[NOTE]
The REST API will be deprecated in Neo4j 4.0.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

===  *Exercise #8: Modify the HTTP port*

In this Exercise, you will modify the default HTTP port used by the HTTP instance and use the new port.

*Exercise steps*:

. Change the HTTP port to a value that is not in use on your system, for example *9999*.
For example, your *neo4j.conf* file should look something like this:

image::L03-Ex8-HTTP9999.png[Ex8-HTTP9999,width=800,align=center]

[start=2]
. Restart the Neo4j instance.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

[start=3]
. Confirm that the port works by entering the following `curl` command that uses the Neo4j HTTP API to create a node, where it will ask you for the password the _neo4j_ user:

----
curl -v -H "Content-Type: application/json" -d '{ "statements" : [ { "statement"  : "CREATE (n) RETURN id(n)" }]}' http://localhost:9999/db/data/transaction/commit -u neo4j
----

image::L03-Ex8-HTTP9999-used.png[Ex8-HTTP9999-used,width=1200,align=center]

[start=4]
. Change the HTTP port back to its default (7474).
. Restart the Neo4j instance.


== Performing online backup and restore

Online backup is used in production where the application cannot tolerate the database being unavailable. In this part of the training, you will learn how to back up and restore a stand-alone Neo4j database. Later in this training, you will learn about backup and restore in a Neo4j Causal Cluster environment.

=== Enabling online backup

To enable a Neo4j instance to be backed up online, you must add these two properties to your *neo4j.conf* file:

----
dbms.backup.enabled=true
dbms.backup.address=<host-address>:<6362-6372>
----

Where _host-address_ is the address of a server from which you will run the backup tool from. You must specify a port number that will not conflict with existing ports used on the backup server.

A best practice for online backup of a stand-alone production database is to perform the backup on a different server. This is because the backup process and consistency checking is expensive and you want to offload this to another server.

A common practice for many enterprises is to back up their databases to Amazon S3 sites. In addition, if any backups are to be stored in S3, they should  be encrypted as well as the channel used to create send the backup to S3.

=== Performing the backup

After you restart the Neo4j instance, you can then perform the backup on the server you specified in _host_address_ as follows with consistency checking:

[listing]
----
neo4j-admin backup --backup-dir=<backup-directory>
                   --name=<backup-instance-directory-name>
                   --from=<Neo4j-instance-host-address:<port>
                   --check-consistency=true
                   --cc-report-dir=<report-directory>
----

This will perform a full backup to _backup-instance-directory-name_ for the Neo4j instance running on _Neo4j-instance-host-address_.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

=== Restoring from a backup

If you need to restore a database from a backup, you must first stop the Neo4j instance. Since the instance is down, you can restore the database on the same server that runs the instance, provided the server has access to the backup location in the network.

Here is how you restore the database from a backup:

[listing]
----
neo4j-admin restore
          --from=<absolute-path-to-backup-instance-directory-name>
          --database=<database-name>
          --force=true
----

You specify _true_ for force so that the existing database will be replaced.

[NOTE]
If you restore a database as _root_, make sure that you change the ownership (recursively) of the database directory to _neo4j:neo4j_ before starting the Neo4j instance.

There are many ways for performing online backups, including incremental backups. See the https://neo4j.com/docs/operations-manual/3.5/backup/[Neo4j Operations Manual] for details.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

===  *Exercise #9: Performing online backup and restore*

In this Exercise, you will perform an online backup of your database where you use the same host for the backup process. Then you will modify the database. Finally, you will restore the database from the backup.

[NOTE]
In your real application, if you were to back up a production stand-alone Neo4j instance, you would use a different host from the host that is running the Neo4j instance.

*Exercise steps*:

. Stop the Neo4j instance.
. Modify the Neo4j configuration so that online backup is enabled and will be done on this same host.
For example, your *neo4j.conf* file should look something like this:

image::L03-Ex9-Backup-config.png[Ex9-Backup-config,width=1000,align=center]

[start=3]
. Restart the Neo4j instance.
. Create a directory named */usr/local/backup* and ensure that it is owned by _neo4j:neo4j_.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

[start=5]
. Perform an online backup of the active database (*movie3.db*).
The result of the backup should look something like this:

image::L03-Ex9-Backup1.png[Ex9-Backup1,width=1000,align=center]

image::L03-Ex9-Backup2.png[Ex9-Backup2,width=1000,align=center]

[start=6]
. Stop the Neo4j instance.
. Corrupt the database like you did earlier in this module. Modify the file *movie3.db/neostore.nodestore.db* by adding some text to the file.
. Run the consistency check tool on *movie3.db* using `neo4j-admin` specifying */usr/local/work/reports* as the directory where the report will be written.

----
 neo4j-admin check-consistency --database=movie3.db --report-dir=/usr/local/reports --verbose=true
----

[start=9]
. The consistency check tool should return that inconsistencies were found.

image::L03-Ex9-Inconsistency.png[Ex9-Inconsistency,width=1000,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

[start=10]
. Restore the *movie3.db* database from the backup.
. Check its consistency.

image::L03-Ex9-Restore.png[Ex9-Restore,width=1000,align=center]

[start=11]
. Confirm that the Neo4j instance starts without error.

== Using the import tool to create a database

The course, _Introduction to Neo4j_, teaches you how to import *.csv* data using `LOAD CSV` in Cypher. `LOAD CSV` works fine for datasets containing fewer than 10M nodes. For large datasets, it may also be possible to import the data with some of the APOC procedures.

Data import for a graph database is resource-intensive because it needs to pre-compute joins (relationships) between records (nodes). For large datasets, a best practice is to import the data  using the `import` command of the `neo4j-admin` tool. This tool creates the database from a set of *.csv* files.

You can read details about using the import tool in the https://neo4j.com/docs/operations-manual/3.5/tools/import/[Neo4j Operations Manual].

=== Creating CSV files for the import

The format of the *.csv* files is important. For both nodes and relationships, header information must be associated with the data. Header information contains an ID to uniquely identify the record, optional node labels or relationship types, and names for the properties representing the imported data. A *.csv* can have a header row, or you can place the header information in a separate file.

In this training, you will use data that has been created for you that represents crimes.

==== CSV files for nodes

Here is portion of the *beats.csv* file with embedded header information for loading nodes of type _Beat_:

----
:ID(Beat),id,:LABEL
1132,1132,Beat
0813,0813,Beat
0513,0513,Beat
----

The *beats.csv* records represent data that will be loaded into a node with the label _Beat_. In this example the record ID is the same as the _id_ property value that will be used to create the node in the graph.

Here is an example of the *crimes_header.csv* header file for loading nodes of type _Crime_:

----
:ID(Crime),id,:LABEL,date,description
----

The nodes loaded with *Crimes_header.csv* will have the label, _:LABEL_. In addition, the data in the associated *crimes.csv* file will have values for the ID of the record, and property values for _id_, _date_, and _description_.

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

And here is a portion of the associated *crimes.csv* file for loading nodes of type _Crime_:

----
8920441,8920441,Crime,12/07/2012 07:50:00 AM,AUTOMOBILE
4730813,4730813,Crime,05/09/2006 08:20:00 AM,POCKET-PICKING
7150780,7150780,Crime,09/28/2009 01:00:00 AM,CHILD ABANDONMENT
4556970,4556970,Crime,12/16/2005 08:39:24 PM,POSS: CANNABIS 30GMS OR LESS
9442492,9442492,Crime,12/28/2013 12:15:00 PM,OVER $500
----

In addition,  this dataset includes information about the types of crimes. These nodes are created without a label for the node, but their ID, _PrimaryType_ will be used to link them to _Crime_ nodes. Here is a portion of the *primaryTypes.csv* file for loading these nodes:

----
:ID(PrimaryType),crimeType
ARSON,ARSON
OBSCENITY,OBSCENITY
ROBBERY,ROBBERY
THEFT,THEFT
CRIM SEXUAL ASSAULT,CRIM SEXUAL ASSAULT
BURGLARY,BURGLARY
----

==== CSV files for relationships

*.csv* files for loading relationships contain a row for every relationship where the ID for the starting and ending node is specified, as well as the relationship type. If you do not specify the relationship in the file, then you must specify it in the arguments to the import tool.


Here is a portion of the *crimesBeats.csv* file that will be used to create the _:ON_BEAT_ relationships between _Crime_ and _Beat_ nodes:

----
:START_ID(Crime),:END_ID(Beat),:TYPE
6978096,0911,ON_BEAT
3170923,2511,ON_BEAT
3073515,1012,ON_BEAT
8157905,0113,ON_BEAT
----

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

Here is a portion of a portion of the *crimesPrimaryTypes.csv* file that will be used to create the  relationships between the _Crime_ nodes and the nodes that contain the _CrimeType_ data:

----
:START_ID(Crime),:END_ID(PrimaryType)
5221115,NARCOTICS
4522835,DECEPTIVE PRACTICE
3432518,BATTERY
6439993,CRIMINAL TRESPASS
----

The relationship, _:TYPE_ is not specified in this file so it will be specified in the arguments when you load the data from this file.

=== Importing the data

After you have created or obtained the *.csv* files for the data, you import the data. The data import creates a database and you must run the import tool with the Neo4j instance stopped.

Here is the simplified syntax for creating a database from *.csv* files:

----
neo4j-admin import  --database <database-name>
                    --nodes[:Label1:Label2] [<rheader-csv-file-1>,]<csv-file-1>
					--nodes[:Label1:Label2] [<rheader-csv-file-2>,]<csv-file-2>
					--nodes[:Label1:Label2] [<rheader-csv-file-n>,]<csv-file-n>
					--relationships[:REL_TYPE] [<jheader-csv-file-1>,]<join-csv-file-1>
					--relationships[:REL_TYPE] [<jheader-csv-file-2>,]<join-csv-file-2>
					--relationships[:REL_TYPE] [<jheader-csv-file-n>,]<join-csv-file-n>
					--report-file <report-file-path>
----

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

Here is the result of using the `import` command of `neo4j-admin` to create a database and import *.csv* files.

image::Import2.png[Import2,width=1000,align=center]

ifdef::backend-pdf[]
// force page break
<<<
endif::backend-pdf[]

===  *Exercise #10: Importing data with the import command*

In this Exercise, you create a new database by importing data using *.csv* files. Data import is very common when preparing a database for production where the data originally comes from relational tables.


*Exercise steps*:

. Stop the Neo4j instance.
. In a terminal window, create the */usr/local/import* directory.
. Navigate to the *import* directory and download this file: https://s3-us-west-1.amazonaws.com/data.neo4j.com/admin-neo4j/crime-data.zip. *Hint*: use `curl -O` or `wget`.
. Unzip the file. You should have six *.csv* files.
. Examine the contents of the files to become familiar with their format and data.
. Use the `import` command to import the data into a new database named *crimes.db*, using these guidelines:
----
--nodes crimes_header.csv,crimes.csv
--nodes beats.csv
--nodes primaryTypes.csv
--relationships crimesBeats.csv
--relationships:PRIMARY_TYPE crimesPrimaryTypes.csv
----

image::L03-Ex10-Import1.png[Ex10-Import1,width=1000,align=center]

image::L03-Ex10-Import2.png[Ex10-Import2,width=1000,align=center]

[start=7]
. Modify the *neo4j.conf* file to use *crimes.db* as the active database.
. Ensure that the ownership of the *crimes.db* directory and everything under it is owned by _neo4j:neo4j_.
. Start the Neo4j instance.
. Run `cypher-shell` to retrieve the schema of the database and also count the number of _Crime_ nodes in the graph.

image::L03-Ex10-QueryCrimesDB.png[Ex10-QueryCrimesDB,width=1000,align=center]

//[#module-3.quiz]
////
== Check your understanding

=== Question 1

Suppose that you have installed Neo4j Enterprise Edition and have modified the name of the active database in the Neo4j configuration file. What tool and command do you run to create the new database?

Select the correct answer.
[%interactive]
- [ ] [.false-answer]#`neo4j-admin create-database`#
- [ ] [.false-answer]#`neo4j-admin initialize`#
- [ ] [.false-answer]#`neo4j create-database`#
- [ ] [.required-answer]#`neo4j start`#

=== Question 2

Suppose that you want the existing Neo4j database to have the name *ABCRecommendations.db*. Assuming that you have stopped the Neo4j instance, what steps must you perform to modify the name of the database, which currently has a default name of *graph.db*?

Select the correct answers.
[%interactive]
- [ ] [.required-answer]#Rename the *NEO4J_HOME/graph.db* directory to *NEO4J_HOME/ABCRecommendations.db*.#
- [ ] [.required-answer]#Modify *neo4j.conf* to use _dbms.active_database=ABCRecommendations.db_.#
- [ ] [.false-answer]#Run `neo4j-admin rename graph.db ABCRecommendations.db`.#
- [ ] [.false-answer]#Run `neo4j-admin move graph.db ABCRecommendations.db`.#

=== Question 3

How do you copy a database that you want to give to another user?

Select the correct answer.
[%interactive]
- [ ] [.false-answer]#With the Neo4j instance started, run `neo4j-admin copy` providing the location where the copy will be created.#
- [ ] [.false-answer]#With the Neo4j instance stopped, run `neo4j-admin copy` providing the location where the copy will be created.#
- [ ] [.false-answer]#With the Neo4j instance started, run `neo4j-admin dump` providing the location where the dump file will be created.#
- [ ] [.required-answer]#With the Neo4j instance stopped, run `neo4j-admin dump` providing the location where the dump file will be created.#
////
== Summary

You should now be able to:

[square]
* Use neo4j-admin to check the consistency of a Neo4j database.

////
== Grade Quiz and Continue 

++++
<a class="next-section medium button" href="../part-4/">Continue to Module 4</a>
++++

ifdef::backend-html5[]

include::scripts-end.txt[]
++++
<script>
$( document ).ready(function() {
  Intercom('trackEvent','training-admin-view-part3');
});
</script>
++++

endif::backend-html5[]
////
