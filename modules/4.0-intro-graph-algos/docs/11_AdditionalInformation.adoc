= Additional Information
:slug: 11-iga-40-additional-information
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Summary

== Additional information

At the end of this course, we would like to give you some additional information to keep in mind when developing and creating your graph analytics workflow.

=== Labs algorithms

This course only covered the production-quality graph algorithms in the GDS library, but there are more than 30 algorithms available in alpha and beta tier at this moment.
Take a look at the https://neo4j.com/docs/graph-data-science/current/algorithms/[algorithms documentation] to explore all the supported graph algorithms.
You will find link prediction, pathfinding, and node embedding algorithms that we haven't explored in this course.

=== Types of graph

It is vital to understand the type of graph we want to analyze.
Remember, most of the Community detection and Centrality algorithms are designed to run on a monopartite graph.
If we start with a bipartite graph, we might want to use the Similarity algorithms or Cypher projection to infer a monopartite network before moving on to other graph algorithms.
We should always include the Weakly Connected Components algorithm in our graph analytics workflow to learn how the graph is connected.
Disconnected components might skew the results of other graph algorithms, so it is critical to understand how well our graph is connected.
Another thing to keep in mind is the direction of relationships.
Differentiating between directed and undirected networks is of great importance as it has a significant influence on the algorithm's results.
Finally, keep in mind if we want to include the relationship weights as an input of the algorithm.
Sometimes, we might get better results if we include weights, but sometimes they don't produce the desired results.
Test many configuration options and see what works best.

=== Seed parameters

The first step in most community detection algorithms is to initialize each node in its own community. 
In practice, each node gets assigned a unique community id.
In the next step, algorithms use various technics to search for communities within the network.
Community Detection algorithms can return different community ids when executed multiple times on the same graph.
This can be a bit of a nuisance if we want to track how communities evolve over time.
The seed property parameter allows us to define the initial community id for each node.
Using seed property can be thought of as semi-supervised community detection, where we provide the initial community id for some nodes based on prior domain knowledge.
Imagine we are running a daily batch process where you search for communities in your Neo4j graph.
What you want to do each day is to provide the communities from the previous day as the seed values.
There are two reasons.
The first one is that it is easier to track a specific community through time as by providing the communities from the day before as seed property, we make sure that the community ids do not change.
That is unless a community disintegrates. 
The algorithm should also be faster as most of the communities are already calculated from the day before, so the algorithms needs less iteration. 

=== Streaming graph algorithms results

Streaming lots of results with the Neo4j Drivers can be very slow. 
We could either store the results with the *write* mode of the algorithm and query the results later or we could wrap a streamed result in apoc.export.csv procedure to produce a CSV file of results.

=== Neo4j Causal Cluster

Avoid writing to core cluster members.
We will want to run the graph algorithms on a read replica and write the results to CSV (or export somehow).
If we want to store the results back to the cluster, we can add them back to the leader by way of import-csv, or use Kafka to stream the results back.
Another alternative is to create and detach a read replica from the cluster.
We can then run the graph algorithms on that instance.

=== Common concerns

Try to avoid running graph algorithms on a transactional graph.
If algorithms take really long to run, try to use the approximation variants of the algorithm or run the algorithm only on the subset of a graph.
In production, try to use only the Native projection and avoid Cypher projection.

[.quiz]
== Check your understanding

=== Question 1

[.statement]
question

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] xx
- [x] xxxx
- [ ] xxxxxx
- [ ] xxxxxxxx

=== Question 2

[.statement]
question

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] xx
- [ ] xxxx
- [ ] xxxxxx
- [x] xxxxxxxx

=== Question 3

[.statement]
question

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] xx
- [ ] xxxx
- [x] xxxxxx
- [ ] xxxxxxxx

[.summary]
== Summary

In this lesson you learned about some tips and best practices for using the Graph Data Science library for your analyses.
