= Optimizing Property Access
:slug: 04-cqt-40-optimizing-property-access
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Monitoring Queries

== About this module

You have learned some of the ways that you can tune queries by reducing the cardinality of the rows that are passed between the steps of an execution plan.
In this module, you will learn how further rewrite queries so that property access is optimized.

At the end of this module, you should be able to:

[square]
* ??

== When are properties accessed?

During a query, a node or relationship property is accessed when it is used to filter a query and to return results.
Here are some examples.

Here, the _title_ property is accessed for the query and the _releaseYear_ property is accessed when returning the query results.
If the _title_ property is indexed, then the node property need not be accessed as the value is in the index:

[source,cypher]
----
MATCH (m:Movie {title: $movieTitle})
RETURN m.title, m.releaseYear
----

This query is the same as the above query:

[source,cypher]
----
MATCH (m:Movie)
WHERE m.title = $movieTitle
RETURN m.title, m.releaseYear
----

Here, the _primaryRole_ and _secondaryRole_ properties  are accessed for the query and the _name_, _title_, and _roles_ properties are accessed when returning the query results.
You cannot define an "regular" index on a relationship property so for this query, every _ACTED_IN_ relationship's _roles_ property values need to be accessed.
This can be very expensive which is why full-text schema indexes are useful.

[source,cypher]
----
MATCH (actor:Person)-[r:ACTED_IN]->(movie:Movie)
WHERE r.primaryRole CONTAINS $characterString OR r.secondaryRole CONTAINS $characterString
RETURN actor.name, movie.title, r.roles
----

Here is how the previous query could use the index. In order to perform the query, only the index is used, and then because so few rows are found, the access to the _name_, _title_, and _roles_ for a small set of rows is not that expensive.

[source,cypher]
----
CALL db.index.fulltext.queryRelationships(
     "ActedInRoleIndex", $characterString) YIELD relationship
WITH relationship AS rel
MATCH (actor)-[rel]->(movie)
RETURN actor.name, movie.title, rel.roles
----

Your goal for indexing and writing queries should be to minimize the number of properties that need to be accessed during the query.
In addition, you should aim to only return property values that are truly needed by the application.

== Only return what you need

During query processing you may aggregate data and perform multiple `MATCH` clauses with the ultimate goal of returning something to the client.
You should always aim to return the minimum amount of data to the client.

For example, this query will return all properties of all nodes and relationships retrieved for the query:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor, movie
----

Here is the resulting execution plan:

image::returnAll.png[returnAll,width=800,align=center]

If the client is accessing the database over a network, the elapsed time for the query will be longer.

Contrast the previous query with this one:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor.name, movie.title
----

image::returnSome.png[returnSome,width=800,align=center]

The number of db hits is greater, but the elapsed time is smaller. You can imagine that over a network, you would see greater differences in performance.

== Index-based property access (especially with ORDER BY)

If an index was used for the query, then that property value for that node will be cached and you need not go to the database to retrieve it.
Furthermore, if you use `ORDER BY` for a property that was retrieved with the index, it will be very fast because the index already provides the ordering.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

image::retrieveTomsAsPerson.png[retrieveTomsAsPerson,width=800,align=center]

Because there is an index on Person.name, the results are returned automatically in order. That is, it is optional whether you specify `ORDER BY`.

Contrast this to a query where an index cannot be used.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

No index is used for the query and we see that it takes longer to retrieve the nodes.

image::retrieveTomsAsActor.png[retrieveTomsAsActor,width=800,align=center]

And if we want the results sorted, there is an additional step:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name ORDER BY p.name
----

image::retrieveTomsAsActorSorted.png[retrieveTomsAsActorSorted,width=800,align=center]

== Tuning "top ten" types of queries

In a query where a property value is used to order and provide a top or bottom of the result set, you should strive to move the `ORDER BY` and `LIMIT` earlier in the query.

Here is an example. We want to return the 100 most recent movies and their actors, ordered by the release year:

[source,cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors ORDER BY m.releaseYear DESC LIMIT 100
----

image::TopHundred.png[TopHundred,width=800,align=center]

Here is the revised query. We move `ORDER BY` and `LIMIT` to earlier in the query.
Even though we are accessing the _releaseYear_ property earlier, it helps us to limit the number of rows processed.

[source,cypher]
----
PROFILE
MATCH (m:Movie)
WITH m ORDER BY m.releaseYear DESC LIMIT 100
MATCH (m)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors
----

image::TopHundredRevised.png[TopHundredRevised,width=800,align=center]

== Project before expansion

If you are doing a query that requires the same value to be repeated for multiple rows in the result, it is sometimes better to project that value out when the node is distinct, then do the expansion.

Here is an example of this:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN m.title AS Title, actor.name AS Actor
----

With this query, we know that we want to return rows containing the movie title and an actor name.
There will be multiple rows that contain the same movie title.

Here is the execution plan:

image::ProjectAfterExpansion.png[ProjectAfterExpansion,width=800,align=center]

A slightly better way to do this is the project the movie title when you know that node is unique, then do the expansion to retrieve the _Actor_ nodes:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m, m.title AS Title
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN Title, actor.name AS Actor
----

Here is the execution plan:

image::ProjectBeforeExpansion.png[ProjectBeforeExpansion,width=800,align=center]

== Aggregate by nodes not properties

Here is an example where we aggregate by a node property:

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p.name as Actor, collect(m) as Movies
RETURN Actor, Movies
----

Here is the execution plan:

image::AggregateByProperty.png[AggregateByProperty,width=800,align=center]

Depending on the graph, it is better to aggregate by node, rather than by property.

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p, collect(m) as Movies
WITH p.name as Actor, Movies
RETURN Actor, Movies
----

Here is the execution plan which is slightly better for this graph:

image::AggregateByNode.png[AggregateByNode,width=800,align=center]


== Delay access until node is distinct

== Delay access until fewer nodes



[.student-exercise]
== Exercise 2: Prepare for Query Tuning

[.small]
--
In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-query-tuning-exercises]

and follow the instructions for Exercise 2.

[NOTE]
This exercise has 6 steps.
Estimated time to complete: 15 minutes.
--

[.quiz]
== Check your understanding

=== Question 1

[.statement]
Which of the following will impact your query tuning work?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] RAM
- [x] Version of Neo4j
- [x] Disk hardware and software
- [x] Number of Cores

=== Question 2

[.statement]
Which Cypher statement will provide you with count information that you can use to explain the behaviour of the queries you will be tuning?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] CALL db.countInfo()
- [ ] CALL db.count-store()
- [ ] CALL apoc.count-store()
- [x] CALL apoc.meta.stats()

=== Question 3

[.statement]
Why do you warm up the Page Cache?

[.statement]
Select the correct answer.

[%interactive.answers]
- [x] You want as much data from the graph in memory for your queries.
- [ ] You want to make sure the DB Stats are updated.
- [ ] You want the execution plans for queries you will be tuning to be in memory.
- [ ] You want lock all data so that it cannot be modified during query tuning.

[.summary]
== Summary

You should now be able to:

[square]
* Ensure you have the appropriate system hardware and settings that can affect performance.
* Prepare Neo4j configuration settings for query tuning.
* Use a representative data set for your queries.
* Pre-test all queries to ensure expected rows based upon DB Stats.
* Ensure the Page Cache is warmed up.
