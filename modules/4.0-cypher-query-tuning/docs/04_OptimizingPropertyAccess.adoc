= Optimizing Property Access
:slug: 04-cqt-40-optimizing-property-access
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Monitoring Queries

== About this module

You have learned some of the ways that you can tune queries by reducing the cardinality of the rows that are passed between the steps of an execution plan.
In this module, you will learn how further rewrite queries so that property access is optimized.
This lesson includes a number of tips for optimizing property access in a query.

At the end of this module, you should be able to:

[square]
* Describe when properties are accessed in a query.
* Optimize queries by minimizing property access.

== When are properties accessed?

During a query, a node or relationship property is accessed when it is used to filter a query and to return results.
Here are some examples.

Here, the _title_ property is accessed for the query and the _releaseYear_ property is accessed when returning the query results.
If the _title_ property is indexed, then the node property need not be accessed as the value is in the index:

[source,cypher]
----
MATCH (m:Movie {title: $movieTitle})
RETURN m.title, m.releaseYear
----

This query is the same as the above query:

[source,cypher]
----
MATCH (m:Movie)
WHERE m.title = $movieTitle
RETURN m.title, m.releaseYear
----

Here, the _primaryRole_ and _secondaryRole_ properties  are accessed for the query and the _name_, _title_, and _roles_ properties are accessed when returning the query results.
You cannot define an "regular" index on a relationship property so for this query, every _ACTED_IN_ relationship's _roles_ property values need to be accessed.
This can be very expensive which is why full-text schema indexes are useful.

[source,cypher]
----
MATCH (actor:Person)-[r:ACTED_IN]->(movie:Movie)
WHERE r.primaryRole CONTAINS $characterString OR r.secondaryRole CONTAINS $characterString
RETURN actor.name, movie.title, r.roles
----

Here is how the previous query could use the index. In order to perform the query, only the index is used, and then because so few rows are found, the access to the _name_, _title_, and _roles_ for a small set of rows is not that expensive.

[source,cypher]
----
CALL db.index.fulltext.queryRelationships(
     "ActedInRoleIndex", $characterString) YIELD relationship
WITH relationship AS rel
MATCH (actor)-[rel]->(movie)
RETURN actor.name, movie.title, rel.roles
----

Your goal for indexing and writing queries should be to minimize the number of properties that need to be accessed during the query.
In addition, you should aim to only return property values that are truly needed by the application.

== Only return what you need

During query processing you may aggregate data and perform multiple `MATCH` clauses with the ultimate goal of returning something to the client.
You should always aim to return the minimum amount of data to the client.

For example, this query will return all properties of all nodes and relationships retrieved for the query:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor, movie
----

Here is the resulting execution plan:

image::returnAll.png[returnAll,width=800,align=center]

If the client is accessing the database over a network, the elapsed time for the query will be longer.

Contrast the previous query with this one:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor.name, movie.title
----

image::returnSome.png[returnSome,width=800,align=center]

The number of db hits is greater, but the elapsed time is smaller. You can imagine that over a network, you would see greater differences in performance.

In addition, you should strive to limit the number of rows returned as accessing fewer rows to obtain property values will be faster.

Here we limit the number of rows returned by only returning movies
that have greater than _$maxActors_ actors.
This will be a subset of all movies.

[source,cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a)
WITH  m, collect(a) as actors
WHERE size(actors) > $maxActors
RETURN  m.title, m.releaseYear, actors
----

Here is another example where we want to only return _$numResults_

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a)
WITH  m, collect(a) as actors LIMIT $numResults
RETURN  m.title, m.releaseYear, actors
----

== Index-based property access (especially with ORDER BY)

If an index was used for the query, then that property value for that node will be cached and you need not go to the database to retrieve it.
Furthermore, if you use `ORDER BY` for a property that was retrieved with the index, it will be very fast because the index already provides the ordering.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

image::retrieveTomsAsPerson.png[retrieveTomsAsPerson,width=800,align=center]

Because there is an index on Person.name, the results are returned automatically in order. That is, it is optional whether you specify `ORDER BY`.

Contrast this to a query where an index cannot be used.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

No index is used for the query and we see that it takes longer to retrieve the nodes.

image::retrieveTomsAsActor.png[retrieveTomsAsActor,width=800,align=center]

And if we want the results sorted, there is an additional step:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name ORDER BY p.name
----

image::retrieveTomsAsActorSorted.png[retrieveTomsAsActorSorted,width=800,align=center]

== Tuning "top ten" types of queries

In a query where a property value is used to order and provide a top or bottom of the result set, you should strive to move the `ORDER BY` and `LIMIT` earlier in the query.

Here is an example. We want to return the 100 most recent movies and their actors, ordered by the release year:

[source,cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors ORDER BY m.releaseYear DESC LIMIT 100
----

image::TopHundred.png[TopHundred,width=800,align=center]

Here is the revised query. We move `ORDER BY` and `LIMIT` to earlier in the query.
Even though we are accessing the _releaseYear_ property earlier, it helps us to limit the number of rows processed.

[source,cypher]
----
PROFILE
MATCH (m:Movie)
WITH m ORDER BY m.releaseYear DESC LIMIT 100
MATCH (m)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors
----

image::TopHundredRevised.png[TopHundredRevised,width=800,align=center]

== Project property values before expansion

If you are doing a query that requires the same value to be repeated for multiple rows in the result, it is sometimes better to project that value out when the node is distinct, then do the expansion.

Here is an example of this:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN m.title AS Title, actor.name AS Actor
----

With this query, we know that we want to return rows containing the movie title and an actor name.
There will be multiple rows that contain the same movie title.

Here is the execution plan:

image::ProjectAfterExpansion.png[ProjectAfterExpansion,width=800,align=center]

A slightly better way to do this is the project the movie title when you know that node is unique, then do the expansion to retrieve the _Actor_ nodes:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m, m.title AS Title
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN Title, actor.name AS Actor
----

Here is the execution plan:

image::ProjectBeforeExpansion.png[ProjectBeforeExpansion,width=800,align=center]

== Aggregate by nodes not properties

Here is an example where we aggregate by a node property:

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p.name as Actor, collect(m) as Movies
RETURN Actor, Movies
----

Here is the execution plan:

image::AggregateByProperty.png[AggregateByProperty,width=800,align=center]

Depending on the graph, it is better to aggregate by node, rather than by property.

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p, collect(m) as Movies
WITH p.name as Actor, Movies
RETURN Actor, Movies
----

Here is the execution plan which is slightly better for this graph:

image::AggregateByNode.png[AggregateByNode,width=800,align=center]

== Delay access until node is distinct

Delaying the minimum number of properties accessed by reducing the number of nodes is a good thing.
Even better is accessing a distinct node.

This is a variation of getting at the property value before expansion.
Here is an example:

[source, cypher]
----
PROFILE
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
RETURN  m.title, m.releaseYear
----

This query returns 30,146 rows.

image::NonDistinctPropertyAccess.png[NonDistinctPropertyAccess,width=800,align=center]

Ideally, you want to access the node property once, so making it distinct helps:

[source, cypher]
----
PROFILE
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
WITH DISTINCT m
RETURN  m.title, m.releaseYear
----

Although the elapsed time is greater, the number of rows returned is much smaller which means less work to get the property values.

image::DistinctPropertyAccess.png[DistinctPropertyAccess,width=800,align=center]

Another example is where aggregation is performed for some of the nodes and the property access is done before the aggregation:

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year AND m.releaseYear > $year
WITH  m, collect(a) as actors
RETURN  m.title, m.releaseYear, actors
----

image::PropertyAccessBeforeAggregation.png[PropertyAccessBeforeAggregation,width=800,align=center]

When we aggregate the actor nodes, the movie nodes are distinct so it is much more efficient to rewrite this query to:

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
WITH  m, collect(a) as actors
WHERE m.releaseYear > $year
RETURN  m.title, m.releaseYear, actors
----

image::PropertyAccessAfterAggregation.png[PropertyAccessAfterAggregation,width=800,align=center]


[.student-exercise]
== Exercise 6: Optimizing Property Access

[.small]
--
In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-query-tuning-exercises]

and follow the instructions for Exercise 6.

[NOTE]
This exercise has 6 steps.
Estimated time to complete: 15 minutes.
--

// Elaine resume here

[.quiz]
== Check your understanding

=== Question 1

[.statement]
Which of the following will impact your query tuning work?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] RAM
- [x] Version of Neo4j
- [x] Disk hardware and software
- [x] Number of Cores

=== Question 2

[.statement]
Which Cypher statement will provide you with count information that you can use to explain the behaviour of the queries you will be tuning?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] CALL db.countInfo()
- [ ] CALL db.count-store()
- [ ] CALL apoc.count-store()
- [x] CALL apoc.meta.stats()

=== Question 3

[.statement]
Why do you warm up the Page Cache?

[.statement]
Select the correct answer.

[%interactive.answers]
- [x] You want as much data from the graph in memory for your queries.
- [ ] You want to make sure the DB Stats are updated.
- [ ] You want the execution plans for queries you will be tuning to be in memory.
- [ ] You want lock all data so that it cannot be modified during query tuning.

[.summary]
== Summary

You should now be able to:

[square]
* Describe when properties are accessed in a query.
* Optimize queries by minimizing property access.
