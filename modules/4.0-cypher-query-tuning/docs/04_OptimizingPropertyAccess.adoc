= Optimizing Property Access
:slug: 04-cqt-40-optimizing-property-access
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Monitoring Queries

== About this module

You have learned some of the ways that you can tune queries by reducing the cardinality of the rows that are passed between the steps of an execution plan.
In this module, you will learn how further rewrite queries so that property access is optimized.
This lesson includes a number of tips for optimizing property access in a query.

At the end of this module, you should be able to:

[square]
* Describe when properties are accessed in a query.
* Optimize queries by minimizing property access.

== When are properties accessed?

During a query, a node or relationship property is accessed when it is used to filter a query and to return results.
Here are some examples.

Here, the _title_ property is accessed for the query and the _releaseYear_ property is accessed when returning the query results.
The _title_ property need not be accessed in the `RETURN` clause because it is cached from the query.
If the _title_ property is indexed, then the node property need not be accessed as the value is in the index:

[source,cypher]
----
MATCH (m:Movie {title: $movieTitle})
RETURN m.title, m.releaseYear
----

This query is the same as the above query:

[source,cypher]
----
MATCH (m:Movie)
WHERE m.title = $movieTitle
RETURN m.title, m.releaseYear
----

Here, the _primaryRole_ and _secondaryRole_ properties  are accessed for the query and the _name_, _title_, and _roles_ properties are accessed when returning the query results.
You cannot define an "regular" index on a relationship property so for this query, every _ACTED_IN_ relationship's _roles_ property values need to be accessed.
This can be very expensive which is why full-text schema indexes are useful.

[source,cypher]
----
MATCH (actor:Person)-[r:ACTED_IN]->(movie:Movie)
WHERE r.primaryRole CONTAINS $characterString OR r.secondaryRole CONTAINS $characterString
RETURN actor.name, movie.title, r.roles
----

Here is how the previous query could use the index. In order to perform the query, only the index is used, and then because so few rows are found, the access to the _name_, _title_, and _roles_ for a small set of rows is not that expensive.

[source,cypher]
----
CALL db.index.fulltext.queryRelationships(
     "ActedInRoleIndex", $characterString) YIELD relationship
WITH relationship AS rel
MATCH (actor)-[rel]->(movie)
RETURN actor.name, movie.title, rel.roles
----

Your goal for indexing and writing queries should be to minimize the number of properties that need to be accessed during the query.
In addition, you should aim to only return property values that are truly needed by the application.

== Only return what you need

During query processing you may aggregate data and perform multiple `MATCH` clauses with the ultimate goal of returning something to the client.
You should always aim to return the minimum amount of data to the client.

For example, this query will return all properties of all nodes and relationships retrieved for the query:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor, movie
----

Here is the resulting execution plan:

image::returnAll.png[returnAll,width=800,align=center]

If the client is accessing the database over a network, the elapsed time for the query will be longer.

If we view the table returned in Neo4j Browser, we see more information:

image::returnAll2.png[returnAll2,width=800,align=center]

Notice that the query really only took 1 ms, but the streaming of the results back to the client took the 16 ms.
From this we can infer that the streaming time was 15 ms.
If the client were on a different system, this streaming time would be greater.

Contrast the previous query with this one:

[source,cypher]
----
PROFILE
MATCH (actor)-[:ACTED_IN]->(movie:Movie)
RETURN actor.name, movie.title
----

image::returnSome.png[returnSome,width=800,align=center]

The number of db hits is greater, but the elapsed time is smaller. You can imagine that over a network, you would see greater differences in performance.

And in the table view, we see that the query took the same amount of time and the streaming of the results was faster because there is less data to stream.

image::returnSome2.png[returnSome2,width=800,align=center]

In addition, you should strive to limit the number of rows returned as accessing fewer rows to obtain property values will be faster.

Here we limit the number of rows returned by only returning movies
that have greater than _$maxActors_ actors.
This will be a subset of all movies.

[source,cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a)
WITH  m, collect(a) as actors
WHERE size(actors) > $maxActors
RETURN  m.title, m.releaseYear, actors
----

Here is another example where we want to only return _$numResults_

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a)
WITH  m, collect(a) as actors LIMIT $numResults
RETURN  m.title, m.releaseYear, actors
----

== Index-based property access

If an index was used for the query, then that property value for that node will be cached and you need not go to the database to retrieve it.
Furthermore, if you use `ORDER BY` for a property that was retrieved with the index, it will be very fast because the index already provides the ordering.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

image::retrieveTomsAsPerson.png[retrieveTomsAsPerson,width=800,align=center]

Because there is an index on Person.name, the results are returned automatically in order. That is, it is optional whether you specify `ORDER BY`.

Contrast this to a query where an index cannot be used.

With this query:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name
----

No index is used for the query and we see that it takes longer to retrieve the nodes.

image::retrieveTomsAsActor.png[retrieveTomsAsActor,width=800,align=center]

And if we want the results sorted, there is an additional step:

[source,cypher]
----
PROFILE
MATCH (p:Actor)
WHERE p.name STARTS WITH $firstName
RETURN p.name ORDER BY p.name
----

image::retrieveTomsAsActorSorted.png[retrieveTomsAsActorSorted,width=800,align=center]

=== Avoiding aggregation with indexes

You learned earlier that eager operators can be expensive.
You can perform operations such as `min()` and `max()` without needing to aggregate, provide there is a supporting index.

Here is an example where we do not have an index on the _Movie.releaseYear_ property.

[source,cypher]
----
PROFILE
MATCH (m:Movie)
WHERE m.releaseYear < $year
RETURN min(m.releaseYear) AS Year
----

image::min1.png[min1,width=800,align=center]

In the execution plan, we see that we need to aggregate all _Movie_ nodes to perform the `min()` operation.

If we had a query that used an index, the aggregation would be avoided because we can get the data we need to find the smallest length title in the index.

[source,cypher]
----
PROFILE
MATCH (m:Movie)
WHERE m.title STARTS WITH $titleString
RETURN min(m.title) AS Title
----

image::min2.png[min2,width=800,align=center]

In the execution plan, we see no aggregation to find the minimum value.

== Tuning "top ten" types of queries

In a query where a property value is used to order and provide a top or bottom of the result set, you should strive to move the `ORDER BY` and `LIMIT` earlier in the query.

Here is an example. We want to return the 100 most recent movies and their actors, ordered by the release year:

[source,cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors ORDER BY m.releaseYear DESC LIMIT 100
----

image::TopHundred.png[TopHundred,width=800,align=center]

Here is the revised query. We move `ORDER BY` and `LIMIT` to earlier in the query.
Even though we are accessing the _releaseYear_ property earlier, it helps us to limit the number of rows processed.

[source,cypher]
----
PROFILE
MATCH (m:Movie)
WITH m ORDER BY m.releaseYear DESC LIMIT 100
MATCH (m)<-[:ACTED_IN]-(actor)
WITH m, collect(actor) AS actors
RETURN m.title as Title, m.releaseYear as Released, actors
----

image::TopHundredRevised.png[TopHundredRevised,width=800,align=center]

== Project property values before expansion

If you are doing a query that requires the same value to be repeated for multiple rows in the result, it is sometimes better to project that value out when the node is distinct, then do the expansion.

Here is an example of this:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN m.title AS Title, actor.name AS Actor
----

With this query, we know that we want to return rows containing the movie title and an actor name.
There will be multiple rows that contain the same movie title.

Here is the execution plan:

image::ProjectAfterExpansion.png[ProjectAfterExpansion,width=800,align=center]

You will notice, however in this execution plan that the _title_ property is actually cached so that it need not be accessed in the `RETURN` clause.
This is an improvement in the query planner for 4.x.

If you were using an earlier release of Neo4j, a slightly better way to do this would be to project the movie title when you know that node is unique, then do the expansion to retrieve the _Actor_ nodes:

[source, cypher]
----
PROFILE
MATCH (m:Movie)
WITH m, m.title AS Title
MATCH (m)<-[:ACTED_IN]-(actor)
RETURN Title, actor.name AS Actor
----

Here is the execution plan:

image::ProjectBeforeExpansion.png[ProjectBeforeExpansion,width=800,align=center]

[NOTE]
As stated earlier in this course, with every release of Neo4j, you must measure your query performance. This is because the Cypher query planner could change and perhaps make your queries perform faster (or slower).

== Aggregate by nodes not properties

Here is an example where we aggregate by a node property:

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p.name as Actor, collect(m) as Movies
RETURN Actor, Movies
----

Here is the execution plan:

image::AggregateByProperty.png[AggregateByProperty,width=800,align=center]

Depending on the graph, it is better to aggregate by node, rather than by property.

[source, cypher]
----
PROFILE
MATCH (p:Person)
WITH p
MATCH (m:Movie)<-[:ACTED_IN]-(p)
WITH p, collect(m) as Movies
WITH p.name as Actor, Movies
RETURN Actor, Movies
----

Here is the execution plan which is slightly better for this graph:

image::AggregateByNode.png[AggregateByNode,width=800,align=center]

== Delay access until node is distinct

Delaying the minimum number of properties accessed by reducing the number of nodes is a good thing.
Even better is accessing a distinct node.

This is a variation of getting at the property value before expansion.
Here is an example:

[source, cypher]
----
PROFILE
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
RETURN  m.title, m.releaseYear
----

This query returns 30,146 rows.

image::NonDistinctPropertyAccess.png[NonDistinctPropertyAccess,width=800,align=center]

Ideally, you want to access the node property once, so making it distinct helps:

[source, cypher]
----
PROFILE
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
WITH DISTINCT m
RETURN  m.title, m.releaseYear
----

Although the elapsed time is greater, the number of rows returned is much smaller which means less work to get the property values.

image::DistinctPropertyAccess.png[DistinctPropertyAccess,width=800,align=center]

Another example is where aggregation is performed for some of the nodes and the property access is done before the aggregation:

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year AND m.releaseYear > $year
WITH  m, collect(a) as actors
RETURN  m.title, m.releaseYear, actors
----

image::PropertyAccessBeforeAggregation.png[PropertyAccessBeforeAggregation,width=800,align=center]

When we aggregate the actor nodes, the movie nodes are distinct so it is much more efficient to rewrite this query to:

[source, cypher]
----
PROFILE
MATCH (m:Movie)<-[:ACTED_IN]-(a:Actor)
WHERE a.born > $year
WITH  m, collect(a) as actors
WHERE m.releaseYear > $year
RETURN  m.title, m.releaseYear, actors
----

image::PropertyAccessAfterAggregation.png[PropertyAccessAfterAggregation,width=800,align=center]


[.student-exercise]
== Exercise 6: More Query Tuning

[.small]
--
In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-query-tuning-exercises]

and follow the instructions for Exercise 6.

[NOTE]
This exercise has 6 steps.
Estimated time to complete: 15 minutes.
--

[.quiz]
== Check your understanding

=== Question 1

[.statement]
Given this query:

[source, cypher]
----
MATCH (m:Movie)
WHERE m.title = $movieTitle
RETURN m.title, m.releaseYear
----

[.statement]
When are the _title_ and _releaseYear_ properties accessed?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] If there are no indexes on _Movie.title_ or _Movie.releaseYear_, the _Movie.title_ property is accessed during the query and the _Movie.releaseYear_ property is accessed in the `RETURN` clause.
- [x] If there is an index only on _Movie.title_, the _Movie.releaseYear_ property is accessed in the `RETURN` clause.
- [x] If there is an index only on _Movie.releaseYear_, the _Movie.title_ property is accessed during the query and the _Movie.releaseYear_ property is accessed in the `RETURN` clause.
- [ ] If there are indexes on both _Movie.title_ and _Movie.releaseYear_, the properties are not accessed, but gotten only from the indexes.

=== Question 2

[.statement]
For a given query, what metrics can you observe related to time?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] total elapsed ms for the query
- [x] ms for the query execution, that does not include results returned
- [ ] ms for the index lookup
- [x] ms for the streaming of the results to the client

=== Question 3

[.statement]
Suppose you have an index on the _Movie.releaseYear_ property. With this code:

[source,cypher]
----
MATCH (m:Movie)
WHERE m.releaseYear > $year
RETURN m.title, m.releaseYear
----

[.statement]
Which statements are true about this code?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] The _title_ property is accessed for the return.
- [ ] The _releaseYear_ property is accessed for the return.
- [x] The records returned are sorted by _releaseYear_.
- [ ] The records returned are in random order.

[.summary]
== Summary

You should now be able to:

[square]
* Describe when properties are accessed in a query.
* Optimize queries by minimizing property access.
