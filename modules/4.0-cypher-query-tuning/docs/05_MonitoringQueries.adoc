= Monitoring Queries
:slug: 05-cqt-40-monitoring-queries
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:module-next-title: Summary

== About this module

You have learned how to measure the performance of queries by profiling them in your development enviromnent.
In your real application you will need to have a more rigorous and documented approach to testing the performance of queries in a test environment.

Even in a production environment, it may be necessary to monitor queries.
You monitor queries to discover any problems in the queries that run during a specific time-period.
For example, if there may be a spike in access to the data, you may want to monitor how it is affecting queries over a period of time.

At the end of this module, you should be able to:

[square]
* Monitor queries that are currently running.
* Monitor historical metrics around queries.


== Review: Query components

You have profiled queries that have these primary components:

. Create the execution plan (compile the  query).
. Execute the query.
. Return results to the client.

== Monitoring current queries

There may be situations where a user/client performs a query that does not return or perhaps takes an extremely long time to return.
In this case, you can run this procedure to view all currently running queries:

[source, cypher]
----
CALL dbms.listQueries()
----

This procedure returns information about all running queries owned by _neo4j_.
In this example, the only query that is running is the one to list the queries.

image::listQueries.png[listQueries,width=800,align=center]

You can also specify what values you want returned from the procedure:

[source,cypher]
----
CALL dbms.listQueries() YIELD  queryId, username, metaData, query, planner , runtime , indexes , startTime , protocol , clientAddress , requestUri , status , resourceInformation , activeLockCount , elapsedTimeMillis , cpuTimeMillis , waitTimeMillis , idleTimeMillis , allocatedBytes , pageHits , pageFaults
----

image::listQueries2.png[listQueries2,width=800,align=center]

=== Queries that return too much data

Here is an example of a query that takes a long time to execute because it returns a lot of data:

[source,cypher]
----
PROFILE MATCH (a)--(b)--(c)--(d)--(e)--(f) RETURN a,b,c,d,e,f
----

This query both processes a lot of data, but also returns a lot of data.

Here is the explanation of the query:

image::ExplainReturnAlotOfData.png[ExplainReturnAlotOfData,width=800,align=center]

When this query runs (on left) , you can see it running when you run listQueries() (:queries) (on right):

image::ProfileReturnAlotOfData.png[ProfileReturnAlotOfData,width=800,align=center]

This query can be killed by the client (on left) by closing the Neo4j browser pane where it is running.
However, in the Neo4j Browser session on the right, we cannot kill it.
Because of the type of query, it has completed executing, but it is now streaming results back to the client.
In this case, it cannot be killed, except for the client that initiated it.

=== Queries that take too long to run

Here is an example of a query that takes a long time to execute because it returns a lot of data:

[source,cypher]
----
EXPLAIN MATCH (a), (b), (c), (d), (e) RETURN count(id(a))
----

Here is the explanation of the query:

image::ExplainTooLongToRun.png[ExplainTooLongToRun,width=800,align=center]

Notice that is does a lot of cartesian products, but only returns one row.

This query can be killed by the client (on left) by closing the Neo4j browser pane where it is running.
However, in the Neo4j Browser session on the right, we cannot kill it.

image::OutOfMemoryTooLongToRun.png[OutOfMemoryTooLongToRun,width=800,align=center]

In this case, it cannot be killed, except for the client that initiated it.
If it is not killed by the client, it will eventually run out of memory.

[.student-exercise]
== Exercise 7: Monitoring Running Queries

[.small]
--
In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-query-tuning-exercises]

and follow the instructions for Exercise 2.

[NOTE]
This exercise has 6 steps.
Estimated time to complete: 15 minutes.
--

[.quiz]
== Check your understanding

=== Question 1

[.statement]
Which of the following will impact your query tuning work?

[.statement]
Select the correct answers.

[%interactive.answers]
- [x] RAM
- [x] Version of Neo4j
- [x] Disk hardware and software
- [x] Number of Cores

=== Question 2

[.statement]
Which Cypher statement will provide you with count information that you can use to explain the behaviour of the queries you will be tuning?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] CALL db.countInfo()
- [ ] CALL db.count-store()
- [ ] CALL apoc.count-store()
- [x] CALL apoc.meta.stats()

=== Question 3

[.statement]
Why do you warm up the Page Cache?

[.statement]
Select the correct answer.

[%interactive.answers]
- [x] You want as much data from the graph in memory for your queries.
- [ ] You want to make sure the DB Stats are updated.
- [ ] You want the execution plans for queries you will be tuning to be in memory.
- [ ] You want lock all data so that it cannot be modified during query tuning.

[.summary]
== Summary

You should now be able to:

[square]
* Ensure you have the appropriate system hardware and settings that can affect performance.
* Prepare Neo4j configuration settings for query tuning.
* Use a representative data set for your queries.
* Pre-test all queries to ensure expected rows based upon DB Stats.
* Ensure the Page Cache is warmed up.
